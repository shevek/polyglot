/* ${header} */
package ${package}.parser;

import java.io.DataInputStream;
import java.io.BufferedInputStream;
import java.io.IOException;
import java.util.Arrays;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.LinkedList;
import java.util.Map;
import java.util.WeakHashMap;
import javax.annotation.CheckForNull;
import javax.annotation.Nonnegative;
import javax.annotation.Nonnull;
import ${package}.node.*;
import ${package}.analysis.Analysis;
import ${package}.analysis.AnalysisAdapter;
import ${package}.lexer.ILexer;
import ${package}.lexer.LexerException;

public class Parser {

    public static final int SHIFT = 0;
    public static final int REDUCE = 1;
    public static final int ACCEPT = 2;
    public static final int ERROR = 3;

    private static class State extends ArrayList<Object> {
        int state;
    }

    private final ILexer lexer;
    private final List<State> stack = new ArrayList<State>();
    private int stackPointer = -1;   // Points to last valid state on stack.

    public Parser(@Nonnull ILexer lexer) {
        this.lexer = lexer;
    }

    @Nonnull
    private int[] lookup(@Nonnull int[][] table, int key, int lowStart) {
        int low = lowStart;
        int high = table.length - 1;

        while (low <= high) {
            int middle = (low + high) >>> 1;
            int[] entry = table[middle];

            if (key < entry[0])
                high = middle - 1;
            else if (key > entry[0])
                low = middle + 1;
            else
                return entry;

        }

        // If the zero index is the default.
        if (lowStart == 1)
            return table[0];
        else
            throw new IllegalStateException("Table lookup failed for " + key);
    }

    @Nonnegative
    private int goTo(@Nonnegative int productionIndex) {
        return lookup(gotoTable[state()], productionIndex, 0)[1];
    }

    @Nonnull
    private State push(@Nonnegative int state) {
        stackPointer++;
        State out;
        if (stackPointer == stack.size()) {
            out = new State();
            stack.add(out);
        } else {
            out = stack.get(stackPointer);
            out.clear();
        }
        out.state = state;
        return out;
    }

    @Nonnegative
    private int state() {
        return stack.get(stackPointer).state;
    }

    @Nonnull
    private State pop() {
        return stack.remove(stackPointer--);
    }

    protected void ignore(@Nonnull Token token) {
    }

    @Nonnull
    public Start parse() throws ParserException, LexerException, IOException {
        push(0);
        for (;;) {
            Token token = this.lexer.peek();
            int index = token.getTokenIndex();
            if (index == -1) {
                ignore(this.lexer.next());
                continue;
            }

            // [1, 2] = Either shift and stack state, or reduce by production number.
            int state = state();    // TODO: Inline
            int[] actionEntry = lookup(actionTable[state], index, 1);
            // dump(token, actionEntry);

            switch (actionEntry[1]) {
                case SHIFT:
                    push(actionEntry[2]).add(this.lexer.next());
                    break;
                case REDUCE:
                    int reduction = actionEntry[2];
                    reduce(reduction);
                    break;
                case ACCEPT:
                    EOF eof = (EOF) this.lexer.next();
                    ${grammar.astProductionRoot.javaTypeName} root = (${grammar.astProductionRoot.javaTypeName}) pop().get(0);
                    return new Start(root, eof);
                case ERROR:
                    throw new ParserException(token, errorTable[actionEntry[2]]);
            }
        }
    }

#if ($helper.large) ## reduce-large

#foreach ($alternativeGroup in $helper.alternativeGroups)
    /* Performs a reduction of an alternative in group ${alternativeGroup.index}. */
    private void reduce${alternativeGroup.javaMethodName}(@Nonnegative int reduction) throws ParserException {
        switch (reduction) {
#foreach ($alternative in $alternativeGroup.alternatives)
            case ${alternative.index}: { // Reduce ${alternative}
                reduce${alternative.javaMethodName}();
                return;
            }
#end
            default:
                throw new IllegalStateException("Illegal reduction in group ${alternativeGroup.javaMethodName}: " + reduction);
        }
    }
#end

    // Grammar is large, using grouped strategy.
    /* Performs a reduction. */
    private void reduce(@Nonnegative int reduction) throws IOException, LexerException, ParserException {
        switch (reduction >> $helper.alternativeGroupShift) {
#foreach ($alternativeGroup in $helper.alternativeGroups)
            case ${alternativeGroup.index}: {
                reduce${alternativeGroup.javaMethodName}(reduction);
                return;
            }
#end## alternativeGroup
            default:
                throw new IllegalStateException("Illegal reduction: " + reduction);
        }
    }

#else ## reduce-large

    // Grammar is small, using simple strategy.
    /* Performs a reduction. */
    private void reduce(@Nonnegative int reduction) throws IOException, LexerException, ParserException {
        switch (reduction) {
#foreach ($production in $grammar.cstProductions)

            // Reductions for $production
#foreach ($alternative in $production.alternatives)
            case ${alternative.index}: { // Reduce ${alternative}
                reduce${alternative.javaMethodName}();
                return;
            }
#end
#end
            default:
                throw new IllegalStateException("Illegal reduction: " + reduction);
        }
    }

#end

    /* Implements a kind of left-associative addition for lists and items. */
    private static class ListBuilder<T> extends ArrayList<T> {
        @Nonnull
        public ListBuilder<T> with(@Nonnull T value) {
            add(value);
            return this;
        }

        @Nonnull
        public ListBuilder<T> withAll(@Nonnull Collection<? extends T> value) {
            addAll(value);
            return this;
        }
    }

#macro(list $root $indent)
#if ($root.items.empty)
${indent}Collections.<${root.javaTypeName}>emptyList()
#else##not empty
${indent}new ListBuilder<${root.javaTypeName}>()
#foreach ($item in $root.items)##
##if ($item.type == "reference" )##
${indent}.with#if($item.listValue)All#end(
#set ($subindent = $indent + "    ")
#expression($item, $subindent)

${indent})
#end##item
#end
#end

## A tree-walk implemented as a recursive velocimacro.
## This is the only difficult bit, really.
## Invariant: Called on new, unindented line, must append indents as appropriate.
## Invariant: Does not append a newline at end of own expression.
#macro(expression $root $indent)
##${indent}// Generating $root
#if ($root.type == "null")
${indent}null##
#elseif ($root.type == "list")
#list($root, $indent)
#elseif ($root.type == "new")
${indent}new ${root.astAlternative.javaTypeName}(
#foreach ($argument in $root.arguments)##
#set ($subindent = $indent + "    ")
#expression($argument, $subindent)#if($velocityHasNext),#{end}

#end##argument
${indent})##
#elseif ($root.type == "reference")##
##${indent}// Element is ${root.element} , transform is ${root.transform}
${indent}${root.element.javaFieldName}__${root.transform.name}##
#else
#stop("ERROR: Unknown type $root.type")
#end
#end## macro

#foreach ($production in $grammar.cstProductions)

// Reductions for $production
#foreach ($alternative in $production.alternatives)## CstAlternativeModel
## Not javadoc - performance sucks too hard.
    /*
     * Rule ${alternative.index}: ${alternative.javaMethodName}.
     * ${alternative.name} =
     *      #foreach ($element in $alternative.elements)$element.name #end

     *          { -> #foreach ($transformExpression in $alternative.transformExpressions)$transformExpression#if($velocityHasNext), #end#end }
     */
    @Nonnull
#if ($helper.isOption("CG_FINDBUGS"))
    @edu.umd.cs.findbugs.annotations.SuppressFBWarnings("DLS_DEAD_LOCAL_STORE")
#end
    private void reduce${alternative.javaMethodName}() {
#foreach ($element in $alternative.elementsReversed)## CstElementModel
        // Pop ${element}
        @Nonnull
        List<Object> ${element.javaFieldName}_nodes = pop();
#foreach ($transformPrototype in $element.symbol.transformPrototypes)
#set($javaTypeName = ${transformPrototype.javaTypeName})
#if ($transformPrototype.list)
#set($javaTypeName = "List<${javaTypeName}>")
#end
        // Extract $element { -> $transformPrototype }
#if (!$element.nullable)
        @Nonnull
#elseif (!$element.list)
        @CheckForNull
#else
        // @CheckForEmpty
#end
        @SuppressWarnings({"unchecked", "unused"})
#if ($helper.isOption("CG_FINDBUGS"))
        @edu.umd.cs.findbugs.annotations.SuppressFBWarnings("DLS_DEAD_LOCAL_STORE")
#end
        $javaTypeName ${element.javaFieldName}__${transformPrototype.name} = ($javaTypeName) ${element.javaFieldName}_nodes.get($foreach.count - 1);
#end##transformPrototype

#end##element
## This push has to happen after we have popped the items, as goTo() looks at the outstanding top state.
        State out = push(goTo(${alternative.production.index}));
#foreach ($transformExpression in $alternative.transformExpressions)
        // Generating: $transformExpression
        out.add(
#expression($transformExpression, "            ")

        );
#end##transformExpression
    }

#end## alternative
#end## production

    private static final int[][][] actionTable /* = {
        // Actions for parser, indexed by LR(k) state. Value is [token, shift, stack-state] or [token, reduce, production-number].
#if (!$helper.large)
#foreach ($state in $automaton.states)
        // Actions for S${state.index}
        {
            { -1, ERROR, $state.errorIndex },   // $automaton.errors.get($state.errorIndex)
#foreach ($action in $state.actionMap.entrySet())
            { $action.key.index, $action.value.action, #{if}($action.value.value)$action.value.value.index#{end} }, // $action.key -> $action.value
#end## action
        }
#end## state
#end## large
    } */ ;

    private static final int[][][] gotoTable /* = {
        // Goto for parser, indexed by LR(k) state. Value is [production, stack-state]
#if (!$helper.large)
#foreach ($state in $automaton.states)
        // Goto for S${state.index}
        {
#foreach ($goto in $state.gotoMap.entrySet())
            { $goto.key.index, $goto.value.index }, // $goto.key -> $goto.value.name
#end## goto
        }
#end## state
#end## large
    } */ ;

    private static final String[] errorTable /* = {
#if (!$helper.large)
#foreach ($error in $automaton.errors)
        "$error",
#end
#end## large
    } */ ;

    private static void readArray(@Nonnull int[] out, @Nonnull DataInputStream in) throws IOException {
        for (int i = 0; i < out.length; i++)
            out[i] = in.readInt();
    }

    @Nonnull
    private static int[][] readTable(@Nonnull DataInputStream in, @Nonnegative int sublength) throws IOException {
        int[][] out = new int[in.readInt()][sublength];
        for (int i = 0; i < out.length; i++)
            readArray(out[i], in);
        return out;
    }

    static {
        try {
            DataInputStream in = new DataInputStream(
#if ($tables.parserDataInline)
                new java.util.zip.GZIPInputStream(
                    new java.io.ByteArrayInputStream(
                        javax.xml.bind.DatatypeConverter.parseBase64Binary("$tables.parserDataText")
                    )
                )
#else
                new BufferedInputStream(
                    Parser.class.getResourceAsStream("parser.dat")
                )
#end
            );

            int parserStateCount = in.readInt();

            actionTable = new int[parserStateCount][][];
            gotoTable = new int[parserStateCount][][];
            for (int i = 0; i < parserStateCount; i++) {
                actionTable[i] = readTable(in, 3);
                gotoTable[i] = readTable(in, 2);
            }

            errorTable = new String[in.readInt()];
            for (int i = 0; i < errorTable.length; i++)
                errorTable[i] = in.readUTF();

            in.close();
        } catch (Exception e) {
            throw new RuntimeException("Failed to load parser table.", e);
        }
    }
}
