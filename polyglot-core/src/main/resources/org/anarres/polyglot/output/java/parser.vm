/* ${header} */
package ${package}.parser;

import java.io.DataInputStream;
import java.io.BufferedInputStream;
import java.io.IOException;
import java.util.Arrays;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.LinkedList;
import java.util.Map;
import java.util.WeakHashMap;
import javax.annotation.CheckForNull;
import javax.annotation.Nonnegative;
import javax.annotation.Nonnull;
import ${package}.node.*;
import ${package}.analysis.Analysis;
import ${package}.analysis.AnalysisAdapter;
import ${package}.lexer.ILexer;
import ${package}.lexer.LexerException;

#if ($helper.isOption("CG_FINDBUGS"))
@edu.umd.cs.findbugs.annotations.SuppressFBWarnings("SKIPPED_CLASS_TOO_BIG")
#end##CG_FINDBUGS
public class ${parserMachine.parserClassName} {

    public static final int SHIFT = 0;
    public static final int REDUCE = 1;
    public static final int ACCEPT = 2;
    public static final int ERROR = 3;

    private static class State extends ArrayList<Object> {
        public State() {
            super(1);
        }
        int state;
        String name;
    }

    private final ILexer lexer;
    private final List<State> stack = new ArrayList<State>();
    private int stackPointer = -1;   // Points to last valid state on stack.

    public ${parserMachine.parserClassName}(@Nonnull ILexer lexer) {
        this.lexer = lexer;
    }

    @Nonnull
    private int[] lookup(@Nonnull int[][] table, int key, int lowStart) {
        int low = lowStart;
        int high = table.length - 1;

        while (low <= high) {
            int middle = (low + high) >>> 1;
            int[] entry = table[middle];

            if (key < entry[0])
                high = middle - 1;
            else if (key > entry[0])
                low = middle + 1;
            else
                return entry;
        }

        // If the zero index is the default.
        if (lowStart == 1)
            return table[0];
        else
            throw new IllegalStateException("Table lookup failed for " + key);
    }

    @Nonnegative
    private int goTo(@Nonnegative int productionIndex) {
        return lookup(gotoTable[state()], productionIndex, 0)[1];
    }

    @Nonnull
    private State push(@Nonnegative int state, @Nonnull String name) {
        stackPointer++;
        State out;
        if (stackPointer == stack.size()) {
            out = new State();
            stack.add(out);
        } else {
            out = stack.get(stackPointer);
            out.clear();
        }
        out.state = state;
        out.name = name;
        return out;
    }

    @Nonnegative
    private int state() {
        return stack.get(stackPointer).state;
    }

    @Nonnull
    private State pop() {
##        return stack.remove(stackPointer--);
        return stack.get(stackPointer--);
    }

    protected void ignore(@Nonnull Token token) {
    }

    @Nonnull
    public ${parserMachine.startClassName} parse() throws ParserException, LexerException, IOException {
        push(0, "${parserMachine.startClassName}");
        for (;;) {
            Token token = this.lexer.peek();
            int index = token.getTokenIndex();
            if (index == -1) {
                ignore(this.lexer.next());
                continue;
            }

            // [1, 2] = Either shift and stack state, or reduce by production number.
            int state = state();    // TODO: Inline
            int[] actionEntry = lookup(actionTable[state], index, 1);
            // dump(token, actionEntry);

            switch (actionEntry[1]) {
                case SHIFT:
## token.getText() hould be TokenModel's descriptiveName annotation if present.
                    push(actionEntry[2], token.getText()).add(this.lexer.next());
                    break;
                case REDUCE:
                    int reduction = actionEntry[2];
                    reduce(reduction);
                    break;
                case ACCEPT:
                    EOF eof = (EOF) this.lexer.next();
                    ${parserMachine.astProductionRoot.javaTypeName} root = (${parserMachine.astProductionRoot.javaTypeName}) pop().get(0);
                    return new ${parserMachine.startClassName}(root, eof);
                case ERROR:
                    StringBuilder buf = new StringBuilder("After");
                    for (int i = 1; i <= stackPointer; i++)
                        buf.append(' ').append(stack.get(i).name);
                    buf.append(", expected [").append(errorTable[actionEntry[2]]);
                    buf.append("] but got ").append(token.getClass().getSimpleName());
                    buf.append(": ").append(token.getText());
                    throw new ParserException(token, buf.toString());
            }
        }
    }

#if ($helper.isLarge($parserMachine)) ## reduce-large

#foreach ($alternativeGroup in $helper.alternativeGroups)
    /* Performs a reduction of an alternative in group ${alternativeGroup.index}. */
    private void reduce${alternativeGroup.javaMethodName}(@Nonnegative int reduction) throws ParserException {
        switch (reduction) {
#foreach ($alternative in $alternativeGroup.alternatives)
#if ($parserMachine.isCstAlternativeReachable($alternative))
#if ($helper.isOption("CG_COMMENT"))
            // Reduce ${alternative}
#end##CG_COMMENT
            case ${alternative.index}:
                reduce${alternative.javaMethodName}();
                return;
#end##isCstAlternativeReachable
#end##foreach alternative in alternativeGroup
            default:
                throw new IllegalStateException("Illegal reduction in group ${alternativeGroup.javaMethodName}: " + reduction);
        }
    }
#end##foreach alternativeGroup

    // Grammar is large, using grouped strategy.
    /* Performs a reduction. */
    private void reduce(@Nonnegative int reduction) throws IOException, LexerException, ParserException {
        switch (reduction >> $helper.alternativeGroupShift) {
#foreach ($alternativeGroup in $helper.alternativeGroups)
            case ${alternativeGroup.index}:
                reduce${alternativeGroup.javaMethodName}(reduction);
                return;
#end## alternativeGroup
            default:
                throw new IllegalStateException("Illegal reduction: " + reduction);
        }
    }

#else ## reduce-large

    // Grammar is small, using simple strategy.
    /* Performs a reduction. */
    private void reduce(@Nonnegative int reduction) throws IOException, LexerException, ParserException {
        switch (reduction) {
#foreach ($production in $grammar.cstProductions)
#if ($helper.isOption("CG_COMMENT"))
            // Reductions for $production
#end##CG_COMMENT
#foreach ($alternative in $production.alternatives)
#if ($parserMachine.isCstAlternativeReachable($alternative))
#if ($helper.isOption("CG_COMMENT"))
            // Reduce ${alternative}
#end##CG_COMMENT
            case ${alternative.index}:
                reduce${alternative.javaMethodName}();
                return;
#end##isCstAlternativeReachable
#end
#end
            default:
                throw new IllegalStateException("Illegal reduction: " + reduction);
        }
    }

#end

    /* Implements a kind of left-associative addition for lists and items. */
    private static class ListBuilder<T> extends ArrayList<T> {
        @Nonnull
        public ListBuilder<T> with(@Nonnull T value) {
            add(value);
            return this;
        }

        @Nonnull
        public ListBuilder<T> withAll(@Nonnull Collection<? extends T> value) {
            addAll(value);
            return this;
        }
    }

#macro(list $root $indent)
#if ($root.items.empty)
${indent}Collections.<${root.javaTypeName}>emptyList()
#else##not empty
${indent}new ListBuilder<${root.javaTypeName}>()
#foreach ($item in $root.items)##
##if ($item.type == "reference" )##
${indent}.with#if($item.listValue)All#end(
#set ($subindent = $indent + "    ")
#expression($item, $subindent)

${indent})
#end##item
#end
#end

## A tree-walk implemented as a recursive velocimacro.
## This is the only difficult bit, really.
## Invariant: Called on new, unindented line, must append indents as appropriate.
## Invariant: Does not append a newline at end of own expression.
#macro(expression $root $indent)
##${indent}// Generating $root
#if ($root.type == "null")
${indent}null##
#elseif ($root.type == "list")
#list($root, $indent)
#elseif ($root.type == "new")
${indent}new ${root.astAlternative.javaTypeName}(
#foreach ($argument in $root.arguments)##
#set ($subindent = $indent + "    ")
#expression($argument, $subindent)#if($velocityHasNext),#{end}

#end##argument
${indent})##
#elseif ($root.type == "reference")##
##${indent}// Element is ${root.element} , transform is ${root.transform}
${indent}${root.element.javaFieldName}__${root.transform.name}##
#else
#stop("ERROR: Unknown type $root.type")
#end
#end## macro

#foreach ($production in $grammar.cstProductions)

#if ($helper.isOption("CG_COMMENT"))
// Reductions for $production
#end##CG_COMMENT
#foreach ($alternative in $production.alternatives)## CstAlternativeModel
#if ($parserMachine.isCstAlternativeReachable($alternative))
#if ($helper.isOption("CG_COMMENT"))
## Not javadoc - performance sucks too hard.
    /*
     * Rule ${alternative.index}: ${alternative.javaMethodName}.
     * ${alternative.name} =
     *      #foreach ($element in $alternative.elements)$element.name #end

     *          { -> #foreach ($transformExpression in $alternative.transformExpressions)$transformExpression#if($velocityHasNext), #end#end }
     */
#end##CG_COMMENT
    @Nonnull
#if ($helper.isOption("CG_FINDBUGS"))
    @edu.umd.cs.findbugs.annotations.SuppressFBWarnings("DLS_DEAD_LOCAL_STORE")
#end##CG_FINDBUGS
    private void reduce${alternative.javaMethodName}() {
#foreach ($element in $alternative.elementsReversed)## CstElementModel
#if ($helper.isOption("CG_COMMENT"))
        // Pop ${element}
#end##CG_COMMENT
        List<Object> ${element.javaFieldName}_nodes = pop();
#foreach ($transformPrototype in $element.symbol.transformPrototypes)
#set($javaTypeName = ${transformPrototype.javaTypeName})
#if ($transformPrototype.list)
#set($javaTypeName = "List<${javaTypeName}>")
#end
#if ($helper.isOption("CG_COMMENT"))
        // Extract $element { -> $transformPrototype }
#end##CG_COMMENT
#if (!$element.nullable)
        @Nonnull
#elseif (!$element.list)
        @CheckForNull
#else
        // @CheckForEmpty
#end
        @SuppressWarnings({"unchecked"})
#if ($helper.isOption("CG_FINDBUGS"))
        @edu.umd.cs.findbugs.annotations.SuppressFBWarnings("DLS_DEAD_LOCAL_STORE")
#end
        $javaTypeName ${element.javaFieldName}__${transformPrototype.name} = ($javaTypeName) ${element.javaFieldName}_nodes.get($foreach.count - 1);
#end##transformPrototype

#end##element
## This push has to happen after we have popped the items, as goTo() looks at the outstanding top state.
        State out = push(goTo(${production.index}), "$production.descriptiveName");
#foreach ($transformExpression in $alternative.transformExpressions)
#if ($helper.isOption("CG_COMMENT"))
        // Generating: $transformExpression
#end##CG_COMMENT
        out.add(
#expression($transformExpression, "            ")

        );
#end##transformExpression
    }

#end## isCstAlternativeReachable
#end## alternative
#end## production

##if ($helper.isOption("CG_COMMENT"))
## automaton is no longer available because multiparsers blows up the heap if we keep them all around.
#if (false)
    private static final int[][][] actionTable /* = {
        // Actions for parser, indexed by LR(k) state. Value is [token, shift, stack-state] or [token, reduce, production-number].
#if (!$helper.isLarge($parserMachine))
#foreach ($state in $automaton.states)
        // Actions for S${state.index}
        {
            { -1, ERROR, $state.errorIndex },   // $automaton.errors.get($state.errorIndex)
#foreach ($action in $state.actionMap.entrySet())
            { $action.key.index, $action.value.action, #{if}($action.value.value)$action.value.value.index#{end} }, // $action.key -> $action.value
#end## action
        }
#end## state
#end## large
    } */ ;

    private static final int[][][] gotoTable /* = {
        // Goto for parser, indexed by LR(k) state. Value is [production, stack-state]
#if (!$helper.isLarge($parserMachine))
#foreach ($state in $automaton.states)
        // Goto for S${state.index}
        {
#foreach ($goto in $state.gotoMap.entrySet())
            { $goto.key.index, $goto.value.index }, // $goto.key -> $goto.value.name
#end## goto
        }
#end## state
#end## large
    } */ ;

    private static final String[] errorTable /* = {
#if (!$helper.isLarge($parserMachine))
#foreach ($error in $automaton.errors)
        "$error",
#end
#end## large
    } */ ;
#else##CG_COMMENT
    private static final int[][][] actionTable;
    private static final int[][][] gotoTable;
    private static final String[] errorTable;
#end##CG_COMMENT

    private static void readArray(@Nonnull int[] out, @Nonnull DataInputStream in) throws IOException {
        for (int i = 0; i < out.length; i++)
            out[i] = in.readInt();
    }

    @Nonnull
    private static int[][] readTable(@Nonnull DataInputStream in, @Nonnegative int sublength) throws IOException {
        int[][] out = new int[in.readInt()][sublength];
        for (int i = 0; i < out.length; i++)
            readArray(out[i], in);
        return out;
    }

    static {
        try {
            DataInputStream in = new DataInputStream(
#if ($parserMachine.inline)
                new java.util.zip.GZIPInputStream(
                    new java.io.ByteArrayInputStream(
                        javax.xml.bind.DatatypeConverter.parseBase64Binary("$parserMachine.encodedText")
                    )
                )
#else
                new BufferedInputStream(
                    ${parserMachine.parserClassName}.class.getResourceAsStream("${parserMachine.parserClassName}.dat")
                )
#end
            );

            int parserStateCount = in.readInt();

            actionTable = new int[parserStateCount][][];
            gotoTable = new int[parserStateCount][][];
            for (int i = 0; i < parserStateCount; i++) {
                actionTable[i] = readTable(in, 3);
                gotoTable[i] = readTable(in, 2);
            }

            errorTable = new String[in.readInt()];
            for (int i = 0; i < errorTable.length; i++)
                errorTable[i] = in.readUTF();

            in.close();
        } catch (Exception e) {
            throw new RuntimeException("Failed to load parser table.", e);
        }
    }
}
