/* ${header} */
package ${package}.analysis;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.WeakHashMap;
import javax.annotation.CheckForNull;
import javax.annotation.Nonnegative;
import javax.annotation.Nonnull;
import ${package}.node.*;

/**
 * A default implementation of {@link Visitor} which returns null for all tokens.
 *
 * This is used for the common case of implementing an analysis over
 * all productions in the case where tokens are ignored or not relevant.
 *
 * @param <I> The type of the auxiliary argument to the visitor methods; use Void and pass null if not required.
 * @param <O> The return type of the visitor methods; use Void and return null if not required.
 * @param <X> The common supertype of checked exceptions thrown by the visitor methods; use RuntimeException if not required.
 *
 * @see Visitor
 * @see VisitorAdapter
 */
public abstract class AbstractVisitorAdapter<I, O, X extends Exception> implements Visitor<I, O, X> {

    /**
     * By default, returns null.
     *
     * @return null
     */
    public O visitDefault(@Nonnull Node node, I input) throws X {
        return null;
    }

    /**
     * By default, calls {@link ${esc.h}visitDefault(Node, I)}.
     *
     * @return The return value of {@link ${esc.h}visitDefault(Node, I)}.
     */
    public O visitToken(@Nonnull Token node, I input) throws X {
        return visitDefault(node, input);
    }

#if ($grammar.astProductionRoot)
    /**
     * By default, calls {@link ${esc.h}visitDefault(Node, I)}.
     *
     * @return The return value of {@link ${esc.h}visitDefault(Node, I)}.
     */
    @Override
    public O visitStart(Start node, I input) throws X {
        return visitDefault(node, input);
    }
#end

#foreach ($token in $grammar.tokens)
    /**
     * By default, calls {@link ${esc.h}visitToken(Token, I)}.
     *
     * @return The return value of {@link ${esc.h}visitToken(Token, I)}.
     */
    @Override
    public O visit${token.javaMethodName}(@Nonnull ${token.javaTypeName} node, I input) throws X {
        return visitToken(node, input);
    }

#end

    /**
     * By default, calls {@link ${esc.h}visitToken(Token, I)}.
     *
     * @return The return value of {@link ${esc.h}visitToken(Token, I)}.
     */
    @Override
    public O visitEOF(EOF node, I input) throws X {
        return visitToken(node, input);
    }

    /**
     * By default, calls {@link ${esc.h}visitToken(Token, I)}.
     *
     * @return The return value of {@link ${esc.h}visitToken(Token, I)}.
     */
    @Override
    public O visitInvalidToken(InvalidToken node, I input) throws X {
        return visitToken(node, input);
    }

    /**
     * Equivalent to node.apply(this, input) with safety against nulls.
     *
     * @return The return value of node.apply(this, input), or null if node is null.
     */
    @CheckForNull
    public O applyTo(@CheckForNull Node node, I input) throws X {
        if (node == null)
            return null;
        return node.apply(this, input);
    }

    /**
     * Equivalent to for (node in nodes) node.apply(this) with safety against nulls.
     *
     * @return The list of return values from the node.apply() calls, with null for null nodes.
     */
    @Nonnull
    public List<? extends O> applyTo(@CheckForNull Collection<? extends Node> nodes, I input) throws X {
        if (nodes == null)
            return Collections.<O>emptyList();
        if (nodes.isEmpty())
            return Collections.<O>emptyList();
        List<O> out = new ArrayList<O>();
        for (Node node : nodes)
            out.add(applyTo(node, input));
        return out;
    }

    /**
     * Equivalent to for (node in nodes) node.apply(this) with safety against nulls.
     *
     * @return The list of return values from the node.apply() calls, with null for null nodes.
     */
    @Nonnull
    public List<? extends O> applyTo(@CheckForNull Iterable<? extends Node> nodes, I input) throws X {
        if (nodes == null)
            return Collections.<O>emptyList();
        List<O> out = new ArrayList<O>();
        for (Node node : nodes)
            out.add(applyTo(node, input));
        if (out.isEmpty())
            return Collections.<O>emptyList();
        return out;
    }

}
