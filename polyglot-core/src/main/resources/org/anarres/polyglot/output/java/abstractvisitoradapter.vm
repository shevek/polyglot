/* ${header} */
package ${grammar.package.packageName}.analysis;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.WeakHashMap;
import javax.annotation.CheckForNull;
import javax.annotation.Nonnegative;
import javax.annotation.Nonnull;
import ${grammar.package.packageName}.node.*;

/**
 * A default implementation of {@link Visitor} which returns null for all tokens.
 *
 * This is used for the common case of implementing an analysis over
 * all productions in the case where tokens are ignored or not relevant.
 *
 * @see Visitor
 * @see VisitorAdapter
 */
public abstract class AbstractVisitorAdapter<I, O, X extends Exception> implements Visitor<I, O, X> {

    public O visitDefault(@Nonnull Node node, I input) {
        return null;
    }

    public O visitToken(@Nonnull Token node, I input) {
        return visitDefault(node, input);
    }

#if ($grammar.astProductionRoot)
    @Override
    public O visitStart(Start node, I input) throws X {
        return visitDefault(node, input);
    }
#end

#foreach ($token in $grammar.tokens)
    @Override
    public O visit${token.javaMethodName}(@Nonnull ${token.javaTypeName} node, I input) throws X {
        return visitToken(node, input);
    }

#end

    @Override
    public O visitEOF(EOF node, I input) throws X {
        return visitToken(node, input);
    }

    @Override
    public O visitInvalidToken(InvalidToken node, I input) throws X {
        return visitToken(node, input);
    }

    /** Equivalent to node.apply(this, input) with safety against nulls. */
    @CheckForNull
    public O applyTo(@CheckForNull Node node, I input) throws X {
        if (node == null)
            return null;
        return node.apply(this, input);
    }

    /** Equivalent to for (node in nodes) node.apply(this) with safety against nulls. */
    @Nonnull
    public List<? extends O> applyTo(@CheckForNull Collection<? extends Node> nodes, I input) throws X {
        if (nodes == null)
            return Collections.<O>emptyList();
        if (nodes.isEmpty())
            return Collections.<O>emptyList();
        List<O> out = new ArrayList<O>();
        for (Node node : nodes)
            out.add(applyTo(node, input));
        return out;
    }

    /** Equivalent to for (node in nodes) node.apply(this) with safety against nulls. */
    @Nonnull
    public List<? extends O> applyTo(@CheckForNull Iterable<? extends Node> nodes, I input) throws X {
        if (nodes == null)
            return Collections.<O>emptyList();
        List<O> out = new ArrayList<O>();
        for (Node node : nodes)
            out.add(applyTo(node, input));
        if (out.isEmpty())
            return Collections.<O>emptyList();
        return out;
    }

}
