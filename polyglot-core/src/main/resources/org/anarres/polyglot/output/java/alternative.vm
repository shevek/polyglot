/* ${header} */
package ${grammar.package.packageName}.node;

import java.util.ArrayList;
import java.util.List;
import java.util.ListIterator;
import javax.annotation.CheckForNull;
import javax.annotation.Nonnegative;
import javax.annotation.Nonnull;
import ${package}.analysis.Visitor;

#parse("org/anarres/polyglot/output/java/macros.vm")

#if ($alternative.javadocComment)
$alternative.javadocComment
#elseif ($alternative.production.javadocComment)
$production.javadocComment
#else
## No default javadoc - (a) information leakage, (b) javadoc performance sucks.
## /** ${alternative} */
#end
#annotate($alternative)
public class ${alternative.javaTypeName} extends ${production.javaTypeName}
        implements IAlternative
#implement($alternative)
        {

#foreach ($element in $alternative.elements)
    /** Element ${element.name}. */
#if ($element.list)
    private final List<${element.javaTypeName}> _${element.javaFieldName}_ = new ArrayList<${element.javaTypeName}>();
#else##if element.list
    private ${element.javaTypeName} _${element.javaFieldName}_;
#end##if element.list
#end##foreach alternative.elements

#foreach ($external in $alternative.externals)
    /** External ${external.name}. */
    private ${external.javaTypeName} _${external.javaFieldName}_;
#end##foreach alternative.externals

    /**
     * Constructs a new ${alternative.javaTypeName} and sets all elements.
#foreach ($element in $alternative.elements)
     * @param _${element.javaFieldName}_ See {@link #get${element.javaMethodName}()}.
#end
     */
    public ${alternative.javaTypeName}(
#foreach ($element in $alternative.elements)
        #if($element.nullable)@CheckForNull#{else}@Nonnull#{end}##
#if ($element.list)
        Iterable<? extends ${element.javaTypeName}> _${element.javaFieldName}_#if($velocityHasNext),#end

#else##if element.list
        ${element.javaTypeName} _${element.javaFieldName}_#if($velocityHasNext),#end

#end##if element.list
#end##foreach alternative.elements
        ) {
#foreach ($element in $alternative.elements)
        set${element.javaMethodName}(_${element.javaFieldName}_);
#end##foreach alternative.elements
    }

#if (!$alternative.elements.empty)
    /** Constructs a new ${alternative.javaTypeName} without setting any fields. */
    public ${alternative.javaTypeName}() {
    }
#end

    // Elements
#foreach ($element in $alternative.elements)
#if ($element.list)

    $!element.javadocComment
    @Nonnull
#annotate($element)
    public List<${element.javaTypeName}> get${element.javaMethodName}() {
        return this._${element.javaFieldName}_;
    }

    $!element.javadocComment
    public void set${element.javaMethodName}(#if($element.nullable)@CheckForNull#{else}@Nonnull#{end} Iterable<? extends ${element.javaTypeName}> list)
    {
        for (${element.javaTypeName} e : this._${element.javaFieldName}_) {
            e.parent(null);
        }
        this._${element.javaFieldName}_.clear();

        if (list != null) {
            for (${element.javaTypeName} e : list) {
                Node p = e.parent();
                if (p != null)
                    p.removeChild(e);
                e.parent(this);
                this._${element.javaFieldName}_.add(e);
            }
        }
    }
#else##if element.list

    $!element.javadocComment
#if ($element.nullable)
    @CheckForNull
#else
    @Nonnull
#end
#annotate($element)
    public ${element.javaTypeName} get${element.javaMethodName}() {
        return this._${element.javaFieldName}_;
    }

    $!element.javadocComment
    public void set${element.javaMethodName}(#{if}($element.nullable)@CheckForNull#{else}@Nonnull#{end} ${element.javaTypeName} node) {
        if (this._${element.javaFieldName}_ != null) {
            this._${element.javaFieldName}_.parent(null);
        }

        if (node != null) {
            Node p = node.parent();
            if (p != null)
                p.removeChild(node);
            node.parent(this);
        }

        this._${element.javaFieldName}_ = node;
    }
#end##if element.list
#end##foreach alternative.elements

    // Externals
#foreach ($external in $alternative.externals)

    $!external.javadocComment
#if ($external.nullable)
    @CheckForNull
#elseif (!$external.symbol.primitive)
    @Nonnull
#end
#annotate($external)
    public ${external.javaTypeName} get${external.javaMethodName}() {
        return this._${external.javaFieldName}_;
    }

    $!external.javadocComment
    public void set${external.javaMethodName}(#{if}($external.nullable)@CheckForNull#{elseif}(!$external.symbol.primitive)@Nonnull#{end} ${external.javaTypeName} value) {
        this._${external.javaFieldName}_ = value;
    }
#end##foreach alternative.external

    @Override
    public void removeChild(Node child) {
#foreach ($element in $alternative.elements)
#if ($element.list)
        if (this._${element.javaFieldName}_.remove(child)) {
            return;
        }
#else##if element.list
        if (this._${element.javaFieldName}_ == child) {
            this._${element.javaFieldName}_ = null;
            return;
        }
#end##if element.list
#end##foreach alternative.elements

        throw new IllegalArgumentException("Not a child.");
    }

    @Override
    public void replaceChild(Node prev, Node repl) {
#foreach ($element in $alternative.elements)
#if ($element.list)

        for (ListIterator<${element.javaTypeName}> it = this._${element.javaFieldName}_.listIterator(); it.hasNext(); /**/) {
            if (it.next() == prev) {
                if (repl != null) {
                    it.set(($element.javaTypeName) repl);
                    repl.parent(this);
                    prev.parent(null);
                } else {
                    it.remove();
                    prev.parent(null);
                }
                return;
            }
        }

#else##if element.list

        if (this._${element.javaFieldName}_ == prev) {
            set${element.javaMethodName}((${element.javaTypeName}) repl);
            return;
        }

#end##if element.list
#end##foreach alternative.elements

        throw new IllegalArgumentException("Not a child.");
    }

    @Override
#if ($helper.isOption("CG_FINDBUGS"))
    @edu.umd.cs.findbugs.annotations.SuppressFBWarnings("CN_IDIOM_NO_SUPER_CALL")
#end
    public ${alternative.javaTypeName} clone() {
        return clone(CloneListener.NONE);
    }

    @Override
    public ${alternative.javaTypeName} clone(CloneListener listener) {
        ${alternative.javaTypeName} out = new ${alternative.javaTypeName}(
#foreach ($element in $alternative.elements)
#if ($element.list)
            cloneList(listener, get${element.javaMethodName}())#if($velocityHasNext),#end
#else##if element.list
            cloneNode(listener, get${element.javaMethodName}())#if($velocityHasNext),#end
#end##if element.list
#end##foreach alternative.elements
        );
#foreach ($external in $alternative.externals)
        out.set${external.javaMethodName}(get${external.javaMethodName}());
#end##foreach alternative.externals
        listener.fireNodeCloned(this, out);
        return out;
    }

    @Override
    public void apply(Switch s) {
        s.case${alternative.javaMethodName}(this);
    }

    @Override
    public <I, O, X extends Exception> O apply(Visitor<I, O, X> v, I input) throws X {
        return v.visit${alternative.javaMethodName}(this, input);
    }

    @Override
    public void toStringBuilder(StringBuilder buf) {
#foreach ($element in $alternative.elements)
        toStringBuilder(buf, get${element.javaMethodName}());
#end
    }
}
