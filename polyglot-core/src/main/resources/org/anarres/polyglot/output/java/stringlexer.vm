/* ${header} */
package ${grammar.package.packageName}.lexer;

import javax.annotation.Nonnegative;
import javax.annotation.Nonnull;
import ${grammar.package.packageName}.node.*;

/**
 * A fast string-reading concrete lexer implementation.
 */
public class ${lexerMachine.getLexerClassName("", "String")} extends ${lexerMachine.getLexerClassName("Abstract", "")} {

	protected final String in;
	private int offset;
	private int line;
	private int column;
	private boolean cr;

	public ${lexerMachine.getLexerClassName("", "String")}(@Nonnull String in) {
		this.in = in;
	}

	@Override
	protected Token getToken() throws LexerException {
		int dfa_state = 0;

		final int start_offset = this.offset;
		final int start_line = this.line;
		final int start_column = this.column;
		final String in = this.in;
		final int in_length = in.length();

		int current_offset = this.offset;

		int accept_token = 0;
		int accept_offset = current_offset;

		int state_id = this.state.id();
		final int[][] gotoTableEntry = gotoTable[state_id];
		final int[] acceptTableEntry = acceptTable[state_id];

		for (;;) {
			if (current_offset < in_length) {
				int c = in.charAt(current_offset++);
				int[] gotoTableItem = gotoTableEntry[dfa_state];
				dfa_state = search(gotoTableItem, c);
			} else {
				dfa_state = -1;
			}
#if ($helper.isOption("CG_DEBUG"))
			debug_transition(current_offset, dfa_state);
#end##CG_DEBUG

			if (dfa_state >= 0) {
				// If there was a valid transition found on this character.
				int acceptTableItem = acceptTableEntry[dfa_state];
				if (acceptTableItem != 0) {
					accept_token = acceptTableItem;
					accept_offset = current_offset;
				}
			}
			else {
				// If there was no valid transition found, then we accept from the last accept state.
				int tok_line = start_line + 1;
				int tok_column = start_column + 1;
				accept_at(accept_offset);
#if ($helper.isLarge($lexerMachine)) ## lexer-large
				switch (accept_token >> $helper.lexerGroupShift) {
#foreach ($lexerGroup in $helper.lexerGroups)
					case ${lexerGroup.index}:
						return lex${lexerGroup.javaMethodName}(accept_token, start_offset, current_offset, accept_offset, tok_line, tok_column);
#end## alternativeGroup
					default:
						throw new IllegalStateException("Internal failure: accept_token=" + accept_token + ", but no handler found.");
				} // switch (accept_group)
#else##lexer-large
				switch (accept_token) {

#foreach ($token in ${grammar.tokens})
					case ${token.index}: {
#if ($helper.isOption("CG_DEBUG"))
						debug_accept(start_offset, accept_offset, current_offset, ${token.javaTypeName}.class);
#end##CG_DEBUG
#if ($token.transitional)
						switch (state) {
#foreach ($transition in $token.transitions)
							case ${transition.key.name}: state = State.${transition.value.name}; break;
#end##foreach transition
							default: break;
						}
#end##token.transitional
						return new ${token.javaTypeName}(
#if (!$token.fixed)
							in.substring(start_offset, accept_offset),
#end## token.fixed
							start_offset, tok_line, tok_column);
					}
#end##foreach token
					case 0:
						return reject_at(start_offset, current_offset, tok_line, tok_column);
					default:
						throw new IllegalStateException("Internal failure: accept_token=" + accept_token + ", but no handler found.");
				} // switch (accept_token)
#end##lexer-large
			}
		}
	}
#if ($helper.isLarge($lexerMachine)) ## lexer-large

#foreach ($lexerGroup in $helper.lexerGroups)
	@Nonnull
	private Token lex${lexerGroup.javaMethodName}(
			@Nonnegative int accept_token,
			@Nonnegative int start_offset,
			@Nonnegative int current_offset,
			@Nonnegative int accept_offset,
			@Nonnegative int tok_line,
			@Nonnegative int tok_column) throws LexerException {
		switch (accept_token) {
#foreach ($token in $lexerGroup.tokens)
			case ${token.index}:
#if ($helper.isOption("CG_DEBUG"))
				debug_accept(start_offset, accept_offset, current_offset, ${token.javaTypeName}.class);
#end##CG_DEBUG
#if ($token.transitional)
				switch (state) {
#foreach ($transition in $token.transitions)
					case ${transition.key.name}: state = State.${transition.value.name}; break;
#end##foreach transition
					default: break;
				}
#end##token.transitional
				return new ${token.javaTypeName}(
#if (!$token.fixed)
					in.substring(start_offset, accept_offset),
#end## token.fixed
					start_offset, tok_line, tok_column);
#end##foreach token in lexerGroup
#if ($lexerGroup.index == 0)
			case 0:
				return reject_at(start_offset, current_offset, tok_line, tok_column);
#end
			default:
				throw new IllegalStateException("Illegal token index in group ${lexerGroup.javaMethodName}: " + accept_token);
		}
	}
#end##foreach lexerGroup
#end##large

	private void accept_at(int accept_offset) {
		int current_line = this.line;
		int current_column = this.column;
		boolean current_cr = this.cr;

		for (int i = this.offset; i < accept_offset; i++) {
			int c = in.charAt(i);
			switch (c) {
				case 10:
					if (current_cr) {
						current_cr = false;
					} else {
						current_line++;
						current_column = 0;
					}
					break;
				case 13:
					current_line++;
					current_column = 0;
					current_cr = true;
					break;
				default:
					current_column++;
					current_cr = false;
					break;
			}
		}

		this.offset = accept_offset;
		this.line = current_line;
		this.column = current_column;
		this.cr = current_cr;
	}

	@Nonnull
	private Token reject_at(int start_offset, int current_offset, int tok_line, int tok_column) throws LexerException {
		if (current_offset > start_offset) {
			throw new LexerException(
				new InvalidToken(
					in.substring(start_offset, start_offset + 1),
					start_offset,
					tok_line,
					tok_column),
				// "[" + tok_line + "," + tok_column + "] " +
				"Unknown token: " + in.substring(start_offset, current_offset));
		}
		return new EOF(start_offset, tok_line, tok_column);
	}
#if ($helper.isOption("CG_DEBUG"))

	protected void debug_transition(int current_offset, int dfa_state) {
	}

	protected void debug_accept(int start_offset, int accept_offset, int current_offset, Class<? extends Token> type) {
	}
#end##CG_DEBUG
}
